'use strict';

var _package = require('./package.js');
var path = require('path');
require('module');
var Url = require('url');
var fs = require('fs');
var os = require('os');
var utils = require('./utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);

const isWin = process.platform === 'win32';
const SEP = isWin ? `\\\\+` : `\\/`;
const SEP_ESC = isWin ? `\\\\` : `/`;
const GLOBSTAR = `((?:[^/]*(?:/|$))*)`;
const WILDCARD = `([^/]*)`;
const GLOBSTAR_SEGMENT = `((?:[^${SEP_ESC}]*(?:${SEP_ESC}|$))*)`;
const WILDCARD_SEGMENT = `([^${SEP_ESC}]*)`;

/**
 * Convert any glob pattern to a JavaScript Regexp object
 * @param {String} glob Glob pattern to convert
 * @param {Object} opts Configuration object
 * @param {Boolean} [opts.extended=false] Support advanced ext globbing
 * @param {Boolean} [opts.globstar=false] Support globstar
 * @param {Boolean} [opts.strict=true] be laissez faire about mutiple slashes
 * @param {Boolean} [opts.filepath=''] Parse as filepath for extra path related features
 * @param {String} [opts.flags=''] RegExp globs
 * @returns {Object} converted object with string, segments and RegExp object
 */
function globrex(glob, {extended = false, globstar = false, strict = false, filepath = false, flags = ''} = {}) {
    let regex = '';
    let segment = '';
    let path = { regex: '', segments: [] };

    // If we are doing extended matching, this boolean is true when we are inside
    // a group (eg {*.html,*.js}), and false otherwise.
    let inGroup = false;
    let inRange = false;

    // extglob stack. Keep track of scope
    const ext = [];

    // Helper function to build string and segments
    function add(str, {split, last, only}={}) {
        if (only !== 'path') regex += str;
        if (filepath && only !== 'regex') {
            path.regex += (str === '\\/' ? SEP : str);
            if (split) {
                if (last) segment += str;
                if (segment !== '') {
                    if (!flags.includes('g')) segment = `^${segment}$`; // change it 'includes'
                    path.segments.push(new RegExp(segment, flags));
                }
                segment = '';
            } else {
                segment += str;
            }
        }
    }

    let c, n;
    for (let i = 0; i < glob.length; i++) {
        c = glob[i];
        n = glob[i + 1];

        if (['\\', '$', '^', '.', '='].includes(c)) {
            add(`\\${c}`);
            continue;
        }

        if (c === '/') {
            add(`\\${c}`, {split: true});
            if (n === '/' && !strict) regex += '?';
            continue;
        }

        if (c === '(') {
            if (ext.length) {
                add(c);
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === ')') {
            if (ext.length) {
                add(c);
                let type = ext.pop();
                if (type === '@') {
                    add('{1}');
                } else if (type === '!') {
                    add('([^\/]*)');
                } else {
                    add(type);
                }
                continue;
            }
            add(`\\${c}`);
            continue;
        }
        
        if (c === '|') {
            if (ext.length) {
                add(c);
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === '+') {
            if (n === '(' && extended) {
                ext.push(c);
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === '@' && extended) {
            if (n === '(') {
                ext.push(c);
                continue;
            }
        }

        if (c === '!') {
            if (extended) {
                if (inRange) {
                    add('^');
                    continue
                }
                if (n === '(') {
                    ext.push(c);
                    add('(?!');
                    i++;
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === '?') {
            if (extended) {
                if (n === '(') {
                    ext.push(c);
                } else {
                    add('.');
                }
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === '[') {
            if (inRange && n === ':') {
                i++; // skip [
                let value = '';
                while(glob[++i] !== ':') value += glob[i];
                if (value === 'alnum') add('(\\w|\\d)');
                else if (value === 'space') add('\\s');
                else if (value === 'digit') add('\\d');
                i++; // skip last ]
                continue;
            }
            if (extended) {
                inRange = true;
                add(c);
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === ']') {
            if (extended) {
                inRange = false;
                add(c);
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === '{') {
            if (extended) {
                inGroup = true;
                add('(');
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === '}') {
            if (extended) {
                inGroup = false;
                add(')');
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === ',') {
            if (inGroup) {
                add('|');
                continue;
            }
            add(`\\${c}`);
            continue;
        }

        if (c === '*') {
            if (n === '(' && extended) {
                ext.push(c);
                continue;
            }
            // Move over all consecutive "*"'s.
            // Also store the previous and next characters
            let prevChar = glob[i - 1];
            let starCount = 1;
            while (glob[i + 1] === '*') {
                starCount++;
                i++;
            }
            let nextChar = glob[i + 1];
            if (!globstar) {
                // globstar is disabled, so treat any number of "*" as one
                add('.*');
            } else {
                // globstar is enabled, so determine if this is a globstar segment
                let isGlobstar =
                    starCount > 1 && // multiple "*"'s
                    (prevChar === '/' || prevChar === undefined) && // from the start of the segment
                    (nextChar === '/' || nextChar === undefined); // to the end of the segment
                if (isGlobstar) {
                    // it's a globstar, so match zero or more path segments
                    add(GLOBSTAR, {only:'regex'});
                    add(GLOBSTAR_SEGMENT, {only:'path', last:true, split:true});
                    i++; // move over the "/"
                } else {
                    // it's not a globstar, so only match one path segment
                    add(WILDCARD, {only:'regex'});
                    add(WILDCARD_SEGMENT, {only:'path'});
                }
            }
            continue;
        }

        add(c);
    }


    // When regexp 'g' flag is specified don't
    // constrain the regular expression with ^ & $
    if (!flags.includes('g')) {
        regex = `^${regex}$`;
        segment = `^${segment}$`;
        if (filepath) path.regex = `^${path.regex}$`;
    }

    const result = {regex: new RegExp(regex, flags)};

    // Push the last segment
    if (filepath) {
        path.segments.push(new RegExp(segment, flags));
        path.regex = new RegExp(path.regex, flags);
        path.globstar = new RegExp(!flags.includes('g') ? `^${GLOBSTAR_SEGMENT}$` : GLOBSTAR_SEGMENT, flags);
        result.path = path;
    }

    return result;
}

var globrex_1 = globrex;

const isWin$1 = os__default['default'].platform() === 'win32';

const CHARS = { '{': '}', '(': ')', '[': ']'};
const STRICT = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\)|(\\).|([@?!+*]\(.*\)))/;
const RELAXED = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

/**
 * Detect if a string cointains glob
 * @param {String} str Input string
 * @param {Object} [options] Configuration object
 * @param {Boolean} [options.strict=true] Use relaxed regex if true
 * @returns {Boolean} true if string contains glob
 */
function isglob(str, { strict = true } = {}) {
  if (str === '') return false;
  let match, rgx = strict ? STRICT : RELAXED;

  while ((match = rgx.exec(str))) {
    if (match[2]) return true;
    let idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    let open = match[1];
    let close = open ? CHARS[open] : null;
    if (open && close) {
      let n = str.indexOf(close, idx);
      if (n !== -1)  idx = n + 1;
    }

    str = str.slice(idx);
  }
  return false;
}


/**
 * Find the static part of a glob-path,
 * split path and return path part
 * @param {String} str Path/glob string
 * @returns {String} static path section of glob
 */
function parent(str, { strict = false } = {}) {
  if (isWin$1 && str.includes('/'))
    str = str.split('\\').join('/');

	// special case for strings ending in enclosure containing path separator
	if (/[\{\[].*[\/]*.*[\}\]]$/.test(str)) str += '/';

	// preserves full path in case of trailing path separator
	str += 'a';

	do {str = path__default['default'].dirname(str);}
	while (isglob(str, {strict}) || /(^|[^\\])([\{\[]|\([^\)]+$)/.test(str));

	// remove escape chars and return result
	return str.replace(/\\([\*\?\|\[\]\(\)\{\}])/g, '$1');
}

/**
 * Parse a glob path, and split it by static/glob part
 * @param {String} pattern String path
 * @param {Object} [opts] Options
 * @param {Object} [opts.strict=false] Use strict parsing
 * @returns {Object} object with parsed path
 */
function globalyzer(pattern, opts = {}) {
    let base = parent(pattern, opts);
    let isGlob = isglob(pattern, opts);
    let glob;

    if (base != '.') {
        glob = pattern.substr(base.length);
        if (glob.startsWith('/')) glob = glob.substr(1);
    } else {
        glob = pattern;
    }

    if (!isGlob) {
        base = path__default['default'].dirname(pattern);
        glob = base !== '.' ? pattern.substr(base.length) : pattern;
    }

    if (glob.startsWith('./')) glob = glob.substr(2);
    if (glob.startsWith('/')) glob = glob.substr(1);

    return { base, glob, isGlob };
}


var src = globalyzer;

const { join, resolve, relative } = path__default['default'];
const isHidden = /(^|[\\\/])\.[^\\\/\.]/g;

let CACHE = {};

function walk(output, prefix, lexer, opts, dirname='', level=0) {
  const rgx = lexer.segments[level];
  const dir = resolve(opts.cwd, prefix, dirname);
  const files = fs__default['default'].readdirSync(dir);
  const { dot, filesOnly } = opts;

  let i=0, len=files.length, file;
  let fullpath, relpath, stats, isMatch;

  for (; i < len; i++) {
    fullpath = join(dir, file=files[i]);
    relpath = dirname ? join(dirname, file) : file;
    if (!dot && isHidden.test(relpath)) continue;
    isMatch = lexer.regex.test(relpath);

    if ((stats=CACHE[relpath]) === void 0) {
      CACHE[relpath] = stats = fs__default['default'].lstatSync(fullpath);
    }

    if (!stats.isDirectory()) {
      isMatch && output.push(relative(opts.cwd, fullpath));
      continue;
    }

    if (rgx && !rgx.test(file)) continue;
    !filesOnly && isMatch && output.push(join(prefix, relpath));

    walk(output, prefix, lexer, opts, relpath, rgx && rgx.toString() !== lexer.globstar && level + 1);
  }
}

/**
 * Find files using bash-like globbing.
 * All paths are normalized compared to node-glob.
 * @param {String} str Glob string
 * @param {String} [options.cwd='.'] Current working directory
 * @param {Boolean} [options.dot=false] Include dotfile matches
 * @param {Boolean} [options.absolute=false] Return absolute paths
 * @param {Boolean} [options.filesOnly=false] Do not include folders if true
 * @param {Boolean} [options.flush=false] Reset cache object
 * @returns {Array} array containing matching files
 */
var sync = function (str, opts={}) {
  if (!str) return [];

  let glob = src(str);

  opts.cwd = opts.cwd || '.';

  if (!glob.isGlob) {
    try {
      let resolved = resolve(opts.cwd, str);
      let dirent = fs__default['default'].statSync(resolved);
      if (opts.filesOnly && !dirent.isFile()) return [];

      return opts.absolute ? [resolved] : [str];
    } catch (err) {
      if (err.code != 'ENOENT') throw err;

      return [];
    }
  }

  if (opts.flush) CACHE = {};

  let matches = [];
  const { path } = globrex_1(glob.glob, { filepath:true, globstar:true, extended:true });

  path.globstar = path.globstar.toString();
  walk(matches, glob.base, path, opts, '.', 0);

  return opts.absolute ? matches.map(x => resolve(opts.cwd, x)) : matches;
};

function clean_html(html) {
	return html
		.replace(/<!\[CDATA\[[\s\S]*?\]\]>/gm, '')
		.replace(/(<script[\s\S]*?>)[\s\S]*?<\/script>/gm, '$1</' + 'script>')
		.replace(/(<style[\s\S]*?>)[\s\S]*?<\/style>/gm, '$1</' + 'style>')
		.replace(/<!--[\s\S]*?-->/gm, '');
}

function get_href(attrs) {
	const match = /href\s*=\s*(?:"(.*?)"|'(.*?)'|([^\s>]*))/.exec(attrs);
	return match && (match[1] || match[2] || match[3]);
}

function get_src(attrs) {
	const match = /src\s*=\s*(?:"(.*?)"|'(.*?)'|([^\s>]*))/.exec(attrs);
	return match && (match[1] || match[2] || match[3]);
}

function get_srcset_urls(attrs) {
	const results = [];
	// Note that the srcset allows any ASCII whitespace, including newlines.
	const match = /srcset\s*=\s*(?:"(.*?)"|'(.*?)'|([^\s>]*))/s.exec(attrs);
	if (match) {
		const attr_content = match[1] || match[2] || match[3];
		// Parse the content of the srcset attribute.
		// The regexp is modelled after the srcset specs (https://html.spec.whatwg.org/multipage/images.html#srcset-attribute)
		// and should cover most reasonable cases.
		const regex = /\s*([^\s,]\S+[^\s,])\s*((?:\d+w)|(?:-?\d+(?:\.\d+)?(?:[eE]-?\d+)?x))?/gm;
		let sub_matches;
		while ((sub_matches = regex.exec(attr_content))) {
			results.push(sub_matches[1]);
		}
	}
	return results;
}

const OK = 2;
const REDIRECT = 3;

async function prerender({ dir, out, log, config, force }) {
	const seen = new Set();

	const server_root = path.resolve(dir);
	const app = require(`${server_root}/server/app.js`);

	async function crawl(path$1) {
		if (seen.has(path$1)) return;
		seen.add(path$1);

		const rendered = await app.render(
			{
				host: config.host,
				method: 'GET',
				headers: {},
				path: path$1,
				body: null,
				query: new Url.URLSearchParams()
			},
			{
				only_prerender: !force,
				get_static_file: file => fs.createReadStream(path.join(config.files.assets, file))
			}
		);

		if (rendered) {
			const response_type = Math.floor(rendered.status / 100);
			const headers = rendered.headers;
			const type = headers && headers['content-type'];
			const is_html = response_type === REDIRECT || type === 'text/html';

			const parts = path$1.split('/');
			if (is_html && parts[parts.length - 1] !== 'index.html') {
				parts.push('index.html');
			}

			const file = `${out}${parts.join('/')}`;
			utils.mkdirp(path.dirname(file));

			if (response_type === REDIRECT) {
				const { location } = headers;

				log.warn(`${rendered.status} ${path$1} -> ${location}`);
				fs__default['default'].writeFileSync(
					file,
					`<meta http-equiv="refresh" content="0;url=${encodeURI(location)}">`
				);

				return;
			}

			if (response_type === OK) {
				log.info(`${rendered.status} ${path$1}`);
				fs__default['default'].writeFileSync(file, rendered.body); // TODO minify where possible?
			} else {
				// TODO should this fail the build?
				log.error(`${rendered.status} ${path$1}`);
			}

			const { dependencies } = rendered;

			if (dependencies) {
				for (const path$1 in dependencies) {
					const result = dependencies[path$1];
					const response_type = Math.floor(result.status / 100);

					const is_html = result.headers['content-type'] === 'text/html';

					const parts = path$1.split('/');
					if (is_html && parts[parts.length - 1] !== 'index.html') {
						parts.push('index.html');
					}

					const file = `${out}${parts.join('/')}`;
					utils.mkdirp(path.dirname(file));

					fs__default['default'].writeFileSync(file, result.body);

					if (response_type === OK) {
						log.info(`${result.status} ${path$1}`);
					} else {
						log.error(`${result.status} ${path$1}`);
					}
				}
			}

			if (is_html) {
				const cleaned = clean_html(rendered.body);

				let match;
				const pattern = /<(a|img|link|source)\s+([\s\S]+?)>/gm;

				while ((match = pattern.exec(cleaned))) {
					let hrefs = [];
					const element = match[1];
					const attrs = match[2];

					if (element === 'a' || element === 'link') {
						hrefs.push(get_href(attrs));
					} else {
						if (element === 'img') {
							hrefs.push(get_src(attrs));
						}
						hrefs.push(...get_srcset_urls(attrs));
					}

					hrefs = hrefs.filter(Boolean);

					for (const href of hrefs) {
						const resolved = Url.resolve(path$1, href);
						if (resolved[0] !== '/') continue;

						const parsed = Url.parse(resolved);

						const parts = parsed.pathname.slice(1).split('/').filter(Boolean);
						if (parts[parts.length - 1] === 'index.html') parts.pop();

						const file_exists =
							(parsed.pathname.startsWith(`/${config.appDir}/`) &&
								fs__default['default'].existsSync(`${dir}/client/${parsed.pathname}`)) ||
							fs__default['default'].existsSync(`${out}${parsed.pathname}`) ||
							fs__default['default'].existsSync(`static${parsed.pathname}`) ||
							fs__default['default'].existsSync(`static${parsed.pathname}/index.html`);

						if (file_exists) continue;

						if (parsed.query) ;

						await crawl(parsed.pathname);
					}
				}
			}
		}
	}

	// TODO support other extensions, e.g. .svelte.md?
	const entries = sync('**/*.svelte', { cwd: config.files.routes })
		.map((file) => {
			const parts = file.split('/'); // TODO is this true for glob results on windows?

			if (parts.some((part) => part[0] === '_' || /\[/.test(part))) {
				return null;
			}

			parts[parts.length - 1] = parts[parts.length - 1].replace(/\.svelte$/, '');
			if (parts[parts.length - 1] === 'index') parts.pop();

			return `/${parts.join('/')}`;
		})
		.filter(Boolean);

	for (const entry of entries) {
		await crawl(entry);
	}
}

class Builder {
	#generated_files;
	#config;

	constructor({ generated_files, config, log }) {
		this.#generated_files = generated_files;
		this.#config = config;

		this.log = log;
	}

	copy_client_files(dest) {
		utils.copy(`${this.#generated_files}/client`, dest, (file) => file[0] !== '.');
	}

	copy_server_files(dest) {
		utils.copy(`${this.#generated_files}/server`, dest, (file) => file[0] !== '.');
	}

	copy_static_files(dest) {
		utils.copy(this.#config.files.assets, dest);
	}

	async prerender({ force = false, dest }) {
		await prerender({
			out: dest,
			force,
			dir: this.#generated_files,
			config: this.#config,
			log: this.log
		});
	}
}

async function adapt(config) {
	const [adapter, options] = config.adapter;

	if (!adapter) {
		throw new Error('No adapter specified');
	}

	const log = utils.logger();

	console.log(_package.$.bold().cyan(`\n> Using ${adapter}`));

	const builder = new Builder({
		generated_files: '.svelte/build/optimized',
		config,
		log
	});

	const fn = _package.requireRelative_1(adapter);
	await fn(builder, options);

	log.success('done');
}

exports.adapt = adapt;
//# sourceMappingURL=index6.js.map
